! 3456789 123456789 223456789 323456789 423456789 523456789 623456789 723456789 823456789 923456789 023456789 123456789 223456789 32

! 2016 11 04

module mRandoms

    use, intrinsic :: iso_fortran_env, only : ip ! can't be changed gracefullt
    use mSetPrecision,                 only : rp

    implicit NONE

    integer, parameter, private :: ip = ip ! large integers in this scope

    integer,        private          :: k = 0              ! counter for this scope
    integer ( ip ), private          :: alloc_status  = 0  ! error handling
    character ( len = 512 ), private :: alloc_message = '' ! error handling
    character ( len = * ), parameter :: me_module = 'module mRandoms'  ! self-identification

    !private
    !public bindings
contains ! methods: subroutines and functions

    function byte_flipper ( normal ) result ( byte_flipped )
        integer :: nBytes
        nBytes = bit_size ( normal ) / 8 ! count bytes
        do k = 0, bytes - 1  !  reverse byte order: move LSB in myCount to MSB in u
            call mvbits ( FROM = normal, FROMPOS = k * 8, LEN = 8, TO = byte_flipped, TOPOS = ( bytes - k - 1 ) * 8 )
        end do
    end function byte_flipper

    !   https://stackoverflow.com/questions/23057213/how-to-generate-integer-random-number-in-fortran-90-in-the-range-0-5

    function random_integer_fcn ( UpperBound ) result ( RandomInteger )

        integer ( ip ), intent ( in ) :: UpperBound
        integer ( ip )                :: RandomInteger

        real    ( rp )                :: RandomReal

            call random_number ( RandomReal )           ! 0 <= r < 1
            RandomReal = RandomReal * UpperBound        ! 0 <= r < UpperBound
            RandomInteger = ceiling ( RandomReal, ip )  ! 1 <= RandomInteger <= UpperBound

    end function random_integer_fcn

    ! https://gcc.gnu.org/onlinedocs/gfortran/RANDOM_005fSEED.html

    subroutine init_random_seed_sub ( FlagCheckOS, mySeed )
    ! If mySeed is passed, use it to seed rng and return
    ! Otherwise, create a new seed

        use iso_fortran_env, only: ip

        integer, intent ( IN ), optional :: mySeed ( : )
        logical, intent ( IN ), optional :: FlagCheckOS

        ! rank 1
        integer, allocatable  :: seed ( : )

        ! rank 0
        integer        :: array_size = 0, io_urandom = 0, io_stat = 0, pid = 0, bytes = 0
        integer        :: dt ( 8 ) = 0
        integer ( ip ) :: myCount = 0, byte_flipper = 0

        character ( len = * ), parameter :: me_subroutine = 'subroutine init_random_seed_sub'  ! self-identification
        character ( len = * ), parameter :: stop_msg = 'Fatal error: ' // me_module // ', ' // me_subroutine

            if ( present ( mySeed ) ) then  ! check for user-supplied seed
                call random_seed ( put = mySeed )
                return
            end if  ! present ( mySeed )

            ! interogate for size of seed vector and allocate memory
            call random_seed ( size = array_size )  ! measure seed size for allocation
            allocate ( seed ( n ), stat = alloc_status, errmsg = alloc_message )
            if ( alloc_status /= 0 ) then
                write ( *, 100 ) "integer", "seed"
                write ( *, 110 ) array_size
                write ( *, 120 ) alloc_status
                write ( *, 130 ) trim ( alloc_message )
                stop stop_msg
            end if

            ! attempt to get seed from OS
            present_FlagCheckOS: if ( present ( FlagCheckOS ) ) then
                if ( FlagCheckOS ) then
                    open ( newunit = io_urandom, file = "/dev/urandom", access = "stream", form = "unformatted", action = "read", &
                                                 status = "old",  iostat = io_stat )
                    if ( io_stat == 0 ) then ! able to access urandom
                        read  ( io_urandom ) seed
                        close ( io_urandom )
                        call random_seed ( put = seed )
                        return  ! success - return seed generated by urandom
                    else
                        exit present_FlagCheckOS ! can't use urandom; use the system clock to create a seed
                    end if ! io_stat == 0

                end if  ! FlagCheckOS
            end if present_FlagCheckOS ! present ( FlagCheckOS )

            ! Fallback to XORing the current time and pid.
            ! Useful for parallel applications.
            call system_clock ( count = myCount )

            u = byte_flipper ( myCount )

            pid = getpid ( )  ! get process id
            u = ieor ( u, int ( pid, kind ( u ) ) )
            do k = 1, n
                seed ( k ) = lcg ( u )
            end do

            call random_seed ( put = seed )

            return

            100  format ( /, "Error allocating memory for ", g0, " array ", g0, "." )
            110  format (    "  requested size is ", g0, " elements (", g0, " MB ) " )
            120  format (    "  stat = ", g0 )
            130  format (    "  errmsg = ", g0, "." )

        contains
            ! Simplistic PRNG, sufficient for seeding a better PRNG.
            function lcg ( seed ) result ( random_integer )
                integer        :: random_integer
                integer ( ip ) :: seed

                    if ( seed == 0 ) then
                        seed = 104729
                    else
                        seed = mod ( seed, 4294967296_ip )
                    end if

                    seed   = mod ( seed * 279470273_ip, 4294967291_ip )
                    random_integer = int ( mod ( seed, int ( huge ( 0 ), ip ) ), kind ( 0 ) )
            end function lcg

    end subroutine init_random_seed_sub

end module mRandoms
